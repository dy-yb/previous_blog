---
title: Closure(진행중)
date: 2021-05-15 19:59:00
tags: study swift
---

### Closure

클로저란 사용자의 코드 내에서 전달 기능을 자체적으로 포함하는 기능 블럭입니다. 

클로저는 정의된 컨텍스트로부터 상수와 변수에 대한 참조를 캡쳐하고 저장합니다. 이러한 상수와 변수를 클로징 오버라고 합니다. Swift는 캡쳐의 모든 메모리 관리를 처리합니다.

> note: 캡쳐가 친숙하지 않더라도 걱정하지 마세요. Capturing Values에 관한 글 읽기.

### Capturing Values

클로저는 정의 된 컨텍스트에서 상수와 변수를 '캡쳐' 할 수 있습니다. 클로저는 상수와 변수가 정의되어있었던 본래의 범위가 더 이상 존재하지 않더라도 바디 내에서 상수들과 변수들의 값을 참조하고 수정할 수 있습니다.

스위프트에서 클로저의 가장 간단한 형식은 다른 함수의 바디 내에 작성하는 중첩함수 입니다. 중첩 함수는 외부의 함수의 어떠한 인자, 상수, 변수든지  캡쳐할 수 있습니다. 

다음 예시는 `makeIncrementer` 라는 함수를 호출합니다. 이 함수는 `incrementer`라는 중첩 함수를 포함합니다. 중첩함수 `Incrementer()`는 `runningTotal`과 `amount`라는 두 변수를 캡쳐합니다. 이 값들을 캡쳐한 후에 `incrementer`는 호출될때마다 `amount` 만큼 `runningTotal`을 증가시키는 클로저로 `makeIncrementer`에 의해 반환됩니다.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

`makeIncrementer`의 반환타입은 `() → Int` 입니다. 이것은 간단한 값이 아닌 함수를 반환한다는 의미입니다. 이 함수는 인자를 가지지 않고, 호출될 때 마다 Int형 변수를 반환합니다. 함수가 어떻게 다른 함수를 반환할 수 있는지 알고 싶다면 다음 문서([반환 타입으로써의 함수타입)](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID177)를 보시기 바랍니다.

`makeIncrementer(forIncrement:)` 함수는 `runningTotal` 함수를 호출할 때 현재 `incrementer`의 `running total`값을 저장하는 정수형 변수를 정의하며 이 변수는 0으로 초기화 됩니다.  

`makeIncrementer(forIncrement:)` 함수는 argument label은 `forIncrement`이고 parameter name은 `amount`인 하나의 정수형 파라미터를 가지고 있습니다. 

- Argument label: 외부에서 함수를 호출 할 때 사용되는 파라미터의 이름, '_'를 사용하여 생략 가능
- Parameter name: 함수 내부에서 변수로서 사용될 때 불리는 이름

func functionName(**argumentLabel** **parameterName**: valueType) -> returnType{
    **parameterName** = 0
}
functionName(**argumentLabel**: 100)

인자 값은 runningTotal이 incrementer 함수가 호출되어 반환될 때 마다 얼만큼 증가 될 것인지 파라미터를 통해 지정하고 전달합니다. makeIncrementer 함수는 실제로 값을 증가시키는 기능을 하는 incementer 중첩 함수를 정의 합니다. 이 기능은 단순히 amount를 runningTotal에 값을 더하고 결과를 반환하는 것입니다.

중첩 함수 incrementer만 별도로 보면 조금 이상하게 느껴질 수 있습니다:

```swift
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
```

incrementer() 함수는 아무런 파라미터도 없는데 함수 바디 내에서 runningTotal과 amount를 참조하고 있습니다. 이것은 캡쳐링을 통해 둘러싸인 외부 함수로부터 runningTotal과 amount를 참조하여 내부의 본인이 가진 함수 바디에서 사용합니다. 참조를 캡쳐하는 것은 makeIncrementer 함수 호출이 종료될 때 runningTotal과 amount가 사라지지 않도록 하고, 다음에 incrementer 함수가 다시 호출 될 때 runningTotal을 사용할 수 있도록 합니다.

> 최적화를 위해, Swift는 값을 복사하여 저장하고 캡쳐하는 것 대신에 (나중에)

아래는 실행 시 `makeIncrementer`의 예시입니다.

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
```

위 코드는 호출될 때마다 `runningTotal` 변수에 10을 더하는 증가 함수를 참조하도록 `incrementByTen` 상수를 설정하고 있습니다. 함수가 여러번 호출되면 실행시 다음과 같은 결과가 나옵니다.

```swift
incrementByTen()
// returns a value of 10
incrementByTen()
// returns a value of 20
incrementByTen()
// returns a value of 30
```

만약 두번째 증가자를 생성하면 그 증가자만의 새로운 별도의 runningTotal 변수를 갖게됩니다.

```swift
let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementBySeven()
// returns a value of 7
```

원래의 증가자를 다시 호출하면(`incrementByTen`) 본인의 `runningTotal`변수가 이어서 증가되고, `incrementBySeven`으로 캡처된 변수는 영향을 주지 않습니다.

```swift
incrementByTen()
// returns a value of 40
```

NOTE: 클래스 인스턴스 요소에 클로저를 할당하고, 클로저가 인스턴스 혹은 멤버를 참조하여 그 인스턴스를 캡처하면, 클로저와 인스턴스 사이에 강한 참조 사이클이 형성됩니다. 스위프트에서는 캡처리스트를 통해 그들의 강한 참조 사이클을 깨트립니다. 더 자세한 내용을 원한다면 다음 글을 참조하십시오. Strong Reference Cycles for Closures.

—

함수에서 소개한 전역함수와 중첩함수는 사실 클로저의 특별한 케이스 입니다. 클로저에는 세가지 형식이 있습니다.

- 글로벌 함수는 이름을 가지고 아무런 값도 캡쳐하지 않은 클로저입니다.
- 중첩함수는 이름을 가지고 그들이 둘러싸인 함수로부터 값을 캡쳐할 수 있는 클로저입니다.
- 클로저 표현식은 그들이 둘러싸인 컨텍스트로 부터 값을 캡쳐할 수 있는 간단한 구문으로 쓰여진 이름이 없는 클로저입니다.

스위프트의 클로저 표현식은 일반적인 시나리오에서 어수선한 구문을 줄이는 최적화를 통해 간단 명료한 스타일을 가지고 있습니다.  최적화에는 다음이 포함됩니다:

- 컨텍스트로부터 파라미터와 반환 값 타입 추론
- 단일 표현식 클로저로부터 암시적 반환
- 약식형 인자 이름
- 후치 클로저 구문

### 클로저 표현식(Closer expression)

중첩함수는 더 큰 함수의 부분으로서 자체 포함된 코드 블럭의 이름을 짓고 정의하기에 편리합니다. 그러나 가끔은 완전한 선언과 이름없이 함수와 비슷한 구조의 짧은 버전을 작성하는게 더 유용할 때가 있습니다. 특히 한개 또는 그 이상의 요소로서 함수를 사용하는 함수나 메소드의 경우 더 그렇습니다.

클로저 표현식은 집중적인 구문을 간략하게 인라인 클로저로 작성하는 방법입니다. 클로저 표현식은 목적과 명료성의 손실 없이 간략화한 형식의 클로저를 작성하기위해 여러 구문의 최적화를 제공합니다. 아래 클로저 표현식 예제는 여러 번 반복에 의해 `sorted(by:)`메소드의 단일 예제를 정제함으로써 최적화를 나타내며, 각 예제는 같은 기능을 더 간결한 방법으로 표현합니다.

### 정렬 메소드

스위프트의 기본 라이브러리는 `sorted(by:)` 메소드를 제공합니다. 이 메소드는 알려진 타입의 값의 배열을 정렬 클로저의 결과값을 기반으로 정렬합니다. 한번 이 정렬 프로세스가 완료되고 나면, `sorted(by:)` 메소드는 원래의 배열과 같은 타입과 사이즈를 가지고 요소들이 올바른 순서로 정렬된 새 배열을 반환합니다. 원래의 배열은 이 메소드에 의해 수정되지 않습니다.

아래 클로저 표현식 예제에서는 정렬 메소드를 사용해 알파벳의 역순서대로 String 값의 배열을 정렬할 것입니다.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

정렬 메소드는 배열의 내용과 같은 타입인 두 개의 인자를 사용하는 클로저를 허용하고, 값이 정렬 된 후 첫 번째 값이 두 번째 값의 앞, 뒤 중 어디에 나타나야하는지 `Bool` 값을 반환합니다. 정렬 클로저는 첫 번째값이 두 번째 값의 이전에 나타나야 한다면 `true`값을 반환하고, 그 반대의 경우에는 `false`를 반환합니다.

이 예제는 String 배열을 정렬하기 때문에 정렬 클로저는 `(String, String) -> Bool`타입이 됩니다.

정렬클로저를 제공하는 한가지 방법은 올바른 타입의 일반 함수에 작성하고, 이 것을 인자 값으로서 정렬 메소드에 전달 하면 됩니다.

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
	return s1 > s2
}

var reversedNames = names.sorted(by: backward)
// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

만약 첫 번째 문자열(`s1`)이 두 번째 문자열(`s2`) 보다 크다면, `backward(_:_:)` 함수는 `true` 값을 반환 하고, 정렬된 배열에서 `s1`는 `s2` 이후에 나타나게 됩니다. 문자열 내의 글자 관점에서 "크다"의 의미는 "알파벳 순서가 더 뒤에 나타나야한다"를 의미합니다. 이것은 글자 "B"가 "A"보다 크고, 문자열 "Tom"은 문자열 "Tim"보다 크다는 것을 뜻합니다. 알파벳의 역순으로 정렬하면 "Barry"는 "Alex"의 앞쪽에 정렬될 것입니다.

그러나 단일 표현식 함수 (a>b)를 작성하기 위해 이 방법을 쓰기에는 다소 깁니다. 이번 예제에서는, 더 자주 쓰이는 방식인 클로저 표현구를 이용하여 정렬 클로저를 인라인으로 작성하는 것을 알아보겠습니다.

### Closure Expression syntax

클로저 표현구는 다음 형식을 따릅니다:

```swift
{ (parameters) -> return type in
	statements
}
```

`parameters`는 클로저 표현구에서 ~~in-out~~ 파라미터일 수 있지만, 기본 값을 가질 수는 없습니다. 가변 파라미터의 이름을 지정하면 가변 파라미터를 사용할 수 있습니다. 또한 튜플은 파라미터 타입과 반환 타입으로서 사용할 수 있습니다.

아래 예제는 위 `backward(_:_:)` 함수의 클로저 표현식 버전입니다:

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
	return s1 > s2

})
```

여기서의 파라미터와 반환 타입은 이 인라인 클로저가 `backward(_:_:)`함수에서 선언한 것과 동일합니다. 두 가지 케이스 모두 `(s1: String, s2: String) -> Bool`을 작성한 것입니다.

그러나 인라인 클로저 표현식에서는 파라미터와 반환 값이 중괄호 안에 작성됩니다.

클로저 바디의 시작점에서 `in` 키워드를 볼 수 있습니다. 이 키워드는 클로저의 파라미터들과 반환 값의 정의가 끝났다는 것을 나타내며 클로저의 바디가 시작 됨을 나타냅니다.

클로저의 바디는 매우 짧기 때문에 한 라인으로 작성이 가능합니다.

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

정렬 메소드의 전체 호출이 동일하게 유지되었음을 보여줍니다.
